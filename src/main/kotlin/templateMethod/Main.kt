package org.example.templateMethod

/**
 * Template Method パターン
 * 親クラスの抽象クラスが処理の流れを決める
 * 継承する具象クラスで、細かい処理を実装する
 *
 * メリット
 * コードの再利用: 共通の手順を親クラスで定義し、サブクラスで異なる部分を実装することができ、コードを再利用できます。
 * アルゴリズムの一貫性: アルゴリズムの流れを一貫して保つことができるため、コードの可読性と保守性が向上します。
 * 拡張性: 新しい処理をサブクラスに追加することで、機能を簡単に拡張できます。
 *
 * デメリット
 * 柔軟性の欠如: 親クラスで定義された手順の流れを変更する場合、親クラスの修正が必要となるため柔軟性に欠けることがあります。
 * 継承による複雑化: サブクラスが多くなると、継承関係が複雑になり、コードの理解や保守が難しくなる場合があります。
 * 変更の影響範囲: 親クラスの変更がサブクラスに影響を及ぼし、意図しない動作を引き起こす可能性があります。
 *
 * 使用するタイミング
 * アルゴリズムの骨組みが決まっていて、特定の処理部分のみを変更したいとき
 * 異なるクラスで共通する手順を再利用し、重複コードを避けたいとき
 * 手順が固定されており、サブクラスで実装するべき差分部分があるとき
 * サブクラスに処理方法を変更する自由度を与えつつ、共通の流れは固定したいとき
 *
 * 使用例
 * Web アプリケーションでの認証プロセス
 * パターンを使うことで、共通の認証フロー（入力、バリデーション、成功処理）を親クラスで定義し、認証の方法だけをサブクラスで実装できます。
 * ファイルの処理（CSV、JSON、XML など）
 *　ファイル読み込み → データ解析 → 結果保存という流れを共通で定義し、解析部分（CSV解析、JSON解析など）の実装だけをサブクラスに委譲できます。
 *
 * 似たようなパターン
 * ・Factory Method
 * ・Strategy
 */

fun main() {

    val char = CharDisplay('A')
    char.display()

    val str = StringDisplay("Hello", 5)
    str.display()

}